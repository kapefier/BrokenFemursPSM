---
title: "analysisTRY.Rmd"
author: "Orlando Sagliocco"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```     

# Analysis of Hip Fracture Data (2024) (Dott. Ferri)

## Installation and loading of required packages

```{r, echo=TRUE, results='hide', message=FALSE}
# List of required packages
required_packages <- c(
    "broom", "kableExtra", "pROC", "tidyverse", "parameters",
    "insight", "httpgd", "tableone", "ggplot2", "reshape2", "performance", "caret", "detectseparation",
    "MatchIt", "cobalt"
)

# Install missing packages
installed <- required_packages %in% rownames(installed.packages())
if (any(!installed)) {
    install.packages(required_packages[!installed])
}

# Load necessary libraries
lapply(required_packages, library, character.only = TRUE)
```

I successivi step verranno enumerati seguedo lo [Statistical Analysis Plan](../protocols//StatisticalAnalysisPlan.md).

## 1. Data cleaning and descriptive statistics (frequencies, missing).

Load the dataset & sow first lines.
We are now using manipulated dataset.
Optimal data cleaning routine will be created later on.

```{r}
data <- readRDS("../data/HIPfracture-nonames-mock-dataset.rds")
head(data)
```

L'unica variabile categorica che non è stata convertita in fattore è "deceased", che rappresenta lo stato di decesso al follow-up. Convertiamola in fattore per una corretta analisi.
```{r}
data$deceased <- as.factor(data$deceased)
str(data$deceased)
``` 
Esploriamo la struttura del dataset e otteniamo un sommario delle variabili. 
Rinominiamo alcune variabili per migliore impaginazione (trauma_to_surgery e admission_to_surgery).
```{r}
data <- data %>%
  rename(
    trauma2surg  = trauma_to_surgery,
    adm2surg = admission_to_surgery
  )
```

Eseguiamo un glimpse del dataset.
```{r}
glimpse(data)   
```

Otteniamo un sommario delle variabili.
```{r}
summary(data)
``` 

```{r}

# Define categorical and continuous variables
categorical_vars <- c("female","from", "to",  "ASA", "Risk", "Anestesia",   "Trasfusione", "Intervento", "Complicanze", "fIndex1", "fIndex2", "fIndex3", "fIndex4", "fIndex5","Coro","CognImp", "Disl", "Oncol","Anticoag","Antiagg", "Antipsico", "Antidepress", "BDZ", "Antidol", "Reintervento", "deceased")
continuous_vars <- c("age", "wt", "hght", "BMI", "trauma2surg", "adm2surg", "LOS")
```

Normality tests for continuous variables.
```{r}
normality_results <- lapply(continuous_vars, function(var) {
    shapiro_test <- shapiro.test(data[[var]])
    data.frame(Variable = var, W = shapiro_test$statistic, p_value      = shapiro_test$p.value)        
})
normality_results <- do.call(rbind, normality_results)  
kable(normality_results, caption = "Shapiro-Wilk Normality Test Results for Continuous Variables") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
```
Tutte le variabili continue non seguono una distribuzione normale (p < 0.05).

Identifica i valori missing e visualizza la loro distribuzione.
```{r}
missing_summary <- sapply(data, function(x) sum(is.na(x)))
missing_summary <- data.frame(Variable = names(missing_summary), MissingCount = missing_summary)
missing_summary <- missing_summary %>% filter(MissingCount > 0)
kable(missing_summary, caption = "Missing Values Summary") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
```
Per ora non gestiamo i valori mancanti, ma in futuro potremmo considerare metodi come l'imputazione multipla.

### 1.1. Descriptive statistics and visualization

Creiamo un tableone per le variabili categoriche e continue.   
```{r, message=FALSE}

# Create TableOne
table_one <- CreateTableOne(
    vars = c(continuous_vars, categorical_vars),
    data = data,
    factorVars = categorical_vars,
    strata = "deceased"
)

kable_one <- kableone(
    table_one,
    nonnormal = continuous_vars,
    test = TRUE,
    caption = "Table 1. Descriptive statistics of the study population, by deceased status",
    showAllLevels = TRUE,
    formatOptions = list(big.mark = ","),
    quote = FALSE,
    noSpaces = TRUE,
    nonnormalFun = median
) |>
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
kable_one
```
Commento: significatività tra i due strati (deceduto al follow-up, quando? vs non deceduto) solo per età, findex 5, ASA e risk. Da fare ANOVA per le ASA e risk. Aggiungere il tipo di test nella list.


```{r}
# Plot kernel density for age, BMI by category deceased status
density_vars <- c("age", "BMI")
data_long_density <- melt(
  data[, c("deceased", density_vars)],
  id.vars = "deceased",
  measure.vars = density_vars,
  variable.name = "Variable",
  value.name = "Value"
)
ggplot(data_long_density, aes(x = Value, color = deceased, fill = deceased)) +
  geom_density(alpha = 0.3) +
  facet_wrap(~ Variable, scales = "free") +
  labs(
    title = "Kernel Density Plots of Age and BMI by Deceased Status",
    x = "Value",
    y = "Density"
  ) +
  theme_minimal()
```



Violin plots for continuous variables by deceased status.
```{r}
violin_vars <- c("trauma2surg", "adm2surg", "LOS")
data_long <- melt(
  data[, c("deceased", violin_vars)],
  id.vars = "deceased",
  measure.vars = violin_vars,
  variable.name = "Variable",
  value.name = "Value"
)
ggplot(data_long, aes(x = Variable, y = Value, fill = deceased)) +
    geom_violin(trim = FALSE, alpha = 0.5) +
    geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) +
    labs(title = "Violin Plots of Continuous Variables by Deceased Status", x = "Variable", y = "Value") +
    theme_minimal()
```




## 2. Univariate and multivariate logistic regression analyses to identify predictors of mortality.

```{r}
# Ensure categorical variables are factors
for (cat_var in categorical_vars) {
  if (!is.factor(data[[cat_var]])) {
    data[[cat_var]] <- as.factor(data[[cat_var]])
  }
}

# Filter out variables with only one unique value
all_vars <- c(continuous_vars, categorical_vars)
valid_vars <- all_vars[sapply(all_vars, function(var) length(unique(data[[var]])) > 1)]

# Univariate logistic regression for each predictor
univariate_results <- lapply(
  valid_vars,
  function(var) {
    formula <- as.formula(paste("deceased ~", var))
    model <- glm(formula, data = data, family = binomial)
    tidy_model <- tidy(model)
    tidy_model$Variable <- var
    tidy_model
  }
)
univariate_results <- do.call(rbind, univariate_results)
univariate_results <- univariate_results %>%
  filter(term != "(Intercept)") %>%
  select(Variable, term, estimate, std.error, statistic, p.value) %>%
  mutate(
    OR = exp(estimate),
    Lower_CI = exp(estimate - 1.96 * std.error),
    Upper_CI = exp(estimate + 1.96 * std.error)
  ) %>%
  select(Variable, term, OR, Lower_CI, Upper_CI, p.value)
kable(
  univariate_results,
  caption = "Univariate Logistic Regression Results"
) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE
  )
```
Aggiungiamo commento sui risultati. Quali variabili sembrano essere associate a mortalità?
Le isoliamo per il modello multivariato, considerando p < 0.05. Riportiamo la tabella con in livelli di significatività.
```{r}
# Select variables with p < 0.05 for multivariate model
significant_vars <- unique(univariate_results$Variable[univariate_results$p.value < 0.05])
significant_vars
# Create a summary table for significant variables
sig_table <- univariate_results %>%
    filter(Variable %in% significant_vars) %>%
    mutate(
        Significance = case_when(
            p.value < 0.001 ~ "***",
            p.value < 0.01 ~ "**",
            p.value < 0.05 ~ "*",
            TRUE ~ ""
        )
    )

kable(
    sig_table,
    caption = "Significant Predictors of Mortality (p < 0.05, * indicates significance)"
) %>%
    kable_styling(
        bootstrap_options = c("striped", "hover", "condensed"),
        full_width = FALSE
    )
```

```{r}
# Multivariate logistic regression with significant predictors
multivariate_formula <- as.formula(paste("deceased ~", paste(significant_vars, collapse = " + ")))

multivariate_model <- glm(multivariate_formula, data = data, family = binomial)
summary(multivariate_model)
multivariate_tidy <- tidy(multivariate_model) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    OR = exp(estimate),
    Lower_CI = exp(estimate - 1.96 * std.error),
    Upper_CI = exp(estimate + 1.96 * std.error) 
    ) %>%   
    select(term, OR, Lower_CI, Upper_CI, p.value)

multivariate_tidy <- multivariate_tidy %>%
    mutate(
        Significance = case_when(
            p.value < 0.001 ~ "***",
            p.value < 0.01 ~ "**",
            p.value < 0.05 ~ "*",
            TRUE ~ ""
        )
    )

kable(
    multivariate_tidy,
    caption = "Multivariate Logistic Regression Results (Significance: * p<0.05, ** p<0.01, *** p<0.001)"
) %>%
    kable_styling(
        bootstrap_options = c("striped", "hover", "condensed"),
        full_width = FALSE
    )

```


```{r}
# Model diagnostics
model_diagnostics <- model_performance(multivariate_model)
print(model_diagnostics)

# Check for multicollinearity
vif_values <- check_collinearity(multivariate_model)
print(vif_values)
```

```{r}
used_data <- model.frame(multivariate_model)
used_y <- used_data$deceased
predicted_values <- predict(multivariate_model, type = "response")

# ROC curve using ggplot2
library(pROC)
str(predicted_values)
roc_curve <- roc(used_y, predicted_values)
auc_value <- auc(roc_curve)


roc_df <- data.frame(
    Specificity = rev(roc_curve$specificities),
    Sensitivity = rev(roc_curve$sensitivities)
)

ggplot(roc_df, aes(x = 1 - Specificity, y = Sensitivity)) +
    geom_line(color = "blue", linewidth = 1) +
    geom_abline(linetype = "dashed", color = "grey") +
    labs(
        title = "ROC Curve for Multivariate Logistic Regression Model",
        x = "1 - Specificity",
        y = "Sensitivity",
        subtitle = paste("AUC:", round(auc_value, 3))
    ) +
    theme_minimal()


# Print AUC value
 #print(paste("AUC:", round(auc_value, 3)))
```

 Commento sui risultati del modello multivariato

```{r}

# estrai coefficienti e CI
model_df <- tidy(multivariate_model, conf.int = TRUE, exponentiate = TRUE)
```

vedo i warning, per cui controllo la separazione 
```{r}

  multivariate_model_sep <- glm(
                                  formula=multivariate_formula,
                                  data = data,
                                  family = binomial,
                                  method = "detect_separation"
  )

 multivariate_model_sep


```


```{r}

# seleziona solo le variabili significative (p < 0.05), rimuovendo l'intercetta
signif_vars <- model_df %>%
  filter(p.value < 0.05 & term != "(Intercept)") %>%
  select(term, OR = estimate, Lower_CI = conf.low, Upper_CI = conf.high, p.value)

# aggiungi simbolo di significatività
signif_vars <- signif_vars %>%
  mutate(Significance = "*",
         # colora OR protettivi (<1) e di rischio (>1)
         OR_label = ifelse(OR < 1,
                           paste0("↓ ", round(OR,3), " [", round(Lower_CI,3), "-", round(Upper_CI,3), "]"),
                           paste0("↑ ", round(OR,3), " [", round(Lower_CI,3), "-", round(Upper_CI,3), "]")))

# stampa tabella elegante per R Markdown
signif_vars %>%
  select(term, OR_label, p.value, Significance) %>%
  kable("html", caption = "Significant Variables in Multivariate Logistic Regression") %>%
  kable_styling(full_width = FALSE, position = "left") %>%
  column_spec(2, bold = TRUE, color = ifelse(signif_vars$OR < 1, "blue", "red"))


```

Nel modello multivariato, aumentare l’età, alcune tipologie di trasfusione e positività a fIndex4 aumentano il rischio di decesso, mentre il trattamento con Antidol sembra protettivo. Altri fattori non mostrano effetti chiari. Alcune stime con OR molto grandi o molto piccole hanno ampia incertezza e devono essere interpretate con cautela.
Ogni anno in più aumenta del 7% circa il rischio di decesso. Significativo.
Ricevere il tipo 4 di trasfusione aumenta molto il rischio di decesso (OR ~17x), significativo, ma CI molto ampio → incertezza elevata.
Essere positivi a fIndex4 aumenta il rischio ~6 volte. Significativo.
Essere trattati con Antidol riduce il rischio di decesso di ~86%. Significativo.


Forest plot per visualizzare gli OR del modello multivariato.

```{r}
# Forest plot for multivariate logistic regression results
library(ggplot2)
multivariate_tidy <- multivariate_tidy %>%
  mutate(term = factor(term, levels = rev(term)))     
ggplot(multivariate_tidy, aes(x = term, y = OR)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = Lower_CI, ymax = Upper_CI), width = 0.2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  coord_flip() +
  scale_y_continuous(limits = c(0, 40)) +
  labs(
    title = "Forest Plot of Multivariate Logistic Regression Results",
    x = "Predictor Variables",
    y = "Odds Ratio (OR)"
  ) +
  theme_minimal()
```
la categoria Trasfusione5 separa perfettamente i deceased = 0 dai deceased = 1.
Possibili soluzioni:
- rimuovere la categoria Trasfusione5 dal modello
- raggruppare Trasfusione4 e Trasfusione5
- usare penalized logisti regression (es. ridge, lasso)
- usare Bias-reduced logistic regression




E ora possiamo procedere con la validazione incrociata del modello.
Cross-validation for multivariate logistic regression model
set.seed(123)
definisci metodo di cross-validation (10-fold)
train_control <- trainControl(
  method = "cv",       # cross-validation
  number = 10,         # 10-fold
  classProbs = TRUE,   # necessario per calcolare ROC
  summaryFunction = twoClassSummary # per AUC
)

 prepara i dati: caret vuole fattore con livelli "yes"/"no" o simili
data_cv <- na.omit(data[, c("deceased", "age", "Trasfusione", "fIndex", "Antidol")])

addestra il modello
cv_model <- train(
  multivariate_formula,
  data = data_cv,
  method = "glm",
  family = binomial,
  trControl = train_control,
  metric = "ROC"  # ottimizza in base a ROC/AUC
)

guarda i risultati
cv_model

La validazione incrociata a 10 fold del modello multivariato mostra un AUC medio di circa 0.82, indicando una buona capacità discriminativa del modello nel predire
la mortalità. Tuttavia, la variabilità dell'AUC tra i fold suggerisce che le prestazioni del modello possono variare a seconda del campione di dati utilizzato.

### 2.1 Additional analyses (e.g., interaction terms, non-linear effects) as needed.
Aggiungiamo termini di interazione tra età e trasfusione, e tra età e fIndex4.
```{r}
# Create binary indicator for Trasfusione4
data$Trasfusione4 <- ifelse(as.character(data$Trasfusione) == "4", 1, 0)

# Add interaction terms to the multivariate model
interaction_formula <- as.formula("deceased ~ age * Trasfusione4 + age * fIndex4 + Antidol")
interaction_model <- glm(interaction_formula, data = data, family = binomial)
summary(interaction_model)
interaction_tidy <- tidy(interaction_model) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    OR = exp(estimate),
    Lower_CI = exp(estimate - 1.96 * std.error),
    Upper_CI = exp(estimate + 1.96 * std.error)
  ) %>%
  arrange(desc(OR))
interaction_tidy <- interaction_tidy %>%
    mutate(
        Significance = case_when(
            p.value < 0.001 ~ "***",
            p.value < 0.01 ~ "**",
            p.value < 0.05 ~ "*",
            TRUE ~ ""
        )
    )
kable(
    interaction_tidy,
    caption = "Multivariate Logistic Regression with Interaction Terms"
) %>%
    kable_styling(
        bootstrap_options = c("striped", "hover", "condensed"),
        full_width = FALSE
    )
```

In questo modello con termini di interazione, l'effetto dell'età sulla mortalità varia in base alla presenza di trasfusione di tipo 4 e alla positività a fIndex4. L'interazione tra età e Trasfusione4 è significativa, suggerendo che l'impatto dell'età sul rischio di decesso è più pronunciato nei pazienti che ricevono questo tipo di trasfusione. L'interazione tra età e fIndex4 non è significativa, indicando che l'effetto dell'età non differisce significativamente in base allo stato di fIndex4. Il trattamento con Antidol rimane un fattore protettivo significativo contro la mortalità.


# 3. Propensity Score Matching (PSM) to control for confounding variables when assessing the effect of surgery timing on mortality.
Testo se i propensity score matching è fattibile con questo dataset. Cerco overlap tra le covariate.

```{r}
# Create binary indicator for surgery within 48 hours - variabile di trattamento
data$surgeryin48h <- ifelse(data$trauma2surg <= 2, 1, 0)
data$surgeryin48h <- factor(data$surgeryin48h, levels = c(0,1))
table(data$surgeryin48h)


# supponiamo di voler bilanciare i gruppi in base a età, fIndex4 e Antidol, teniamo fuori Trasfusione4 per evitare separazione perfetta
ps_model <- glm(
  surgeryin48h ~ age + fIndex4 + Antidol,
  data = data,
  family = binomial
)

data$pscore <- predict(ps_model, type = "response")


ggplot(data, aes(x = pscore, fill = surgeryin48h)) +
  geom_density(alpha = 0.4) +
  labs(
    title = "Distribuzione dei Propensity Scores",
    x = "Propensity Score",
    fill = "Surgery ≤48h"
  ) +
  theme_minimal()

summary(ps_model)   # eventuali segni di separation
tapply(data$pscore, data$surgeryin48h, summary)
```

Le due distribuzioni sono molto simili, con forte overlap quasi completo.
Questo è esattamente ciò che serve per fare propensity score matching.

```{r}
match_model <- matchit(
  surgeryin48h ~ age + fIndex4 + Antidol,
  data = data,
  method = "nearest",     # nearest neighbor matching
  ratio = 1               # 1:1 matching
)

summary(match_model)      # verifica il bilanciamento
plot(match_model, type = "jitter")
plot(match_model, type = "qq")
```

```{r}
matched_data <- match.data(match_model)
head(matched_data)
table(matched_data$surgeryin48h)    # numero di pazienti in ciascun gruppo dopo il matching
table(matched_data$deceased)         # numero di decessi nel dataset matched
table(matched_data$surgeryin48h, matched_data$deceased)  # tabella di contingenza   
# Analisi della mortalità nel dataset matched
matched_model <- glm(deceased ~ surgeryin48h + age + fIndex4 + Antidol, data = matched_data, family = binomial)
summary(matched_model)
matched_tidy <- tidy(matched_model) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    OR = exp(estimate),
    Lower_CI = exp(estimate - 1.96 * std.error),
    Upper_CI = exp(estimate + 1.96 * std.error)     
    ) %>%   
    select(term, OR, Lower_CI, Upper_CI, p.value)   %>%
  arrange(desc(OR)) 
matched_tidy <- matched_tidy %>%
    mutate(
        Significance = case_when(
            p.value < 0.001 ~ "***",
            p.value < 0.01 ~ "**",
            p.value < 0.05 ~ "*",
            TRUE ~ ""
        )
    )
kable(
    matched_tidy,
    caption = "Logistic Regression Results on Matched Data"
) %>%
    kable_styling(
        bootstrap_options = c("striped", "hover", "condensed"),
        full_width = FALSE
    )
```
Nel dataset bilanciato tramite propensity score matching, l'intervento chirurgico entro 48 ore non mostra un effetto significativo sulla mortalità al follow-up, suggerendo che il tempismo dell'intervento potrebbe non essere un fattore determinante per la sopravvivenza in questo campione specifico. Tuttavia, l'età avanzata e la positività a fIndex4 rimangono associate a un aumento del rischio di decesso, mentre il trattamento con Antidol continua a mostrare un effetto protettivo significativo. Questi risultati indicano che, una volta bilanciati i gruppi per le covariate chiave, il tempismo dell'intervento chirurgico potrebbe avere un impatto limitato sulla mortalità rispetto ad altri fattori clinici.

🔹 Messaggio globale

- Dopo il propensity score matching:

- L’intervento entro 48h (surgeryin48h) non risulta associato in modo significativo con l’outcome (deceased).

- L’età mostra una tendenza al rischio crescente, ma non significativa al 5%.

- Antidol mantiene un effetto protettivo importante e statisticamente significativo.

- Le altre variabili non hanno raggiunto significatività, probabilmente per limiti di numerosità e potere statistico.

Testiamo il modello anche a 72 e 96 ore.
```{r}  
#

# -------------------------
# 1. Creazione variabili di trattamento
# -------------------------
data$surgeryin48h <- ifelse(data$trauma2surg <= 2, 1, 0)
data$surgeryin72h <- ifelse(data$trauma2surg <= 3, 1, 0)
data$surgeryin96h <- ifelse(data$trauma2surg <= 4, 1, 0)

# Trasforma in fattori
data$surgeryin48h <- factor(data$surgeryin48h, levels = c(0,1))
data$surgeryin72h <- factor(data$surgeryin72h, levels = c(0,1))
data$surgeryin96h <- factor(data$surgeryin96h, levels = c(0,1))

# -------------------------
# 2. Matching separato per ciascuna soglia
# -------------------------
match48 <- matchit(surgeryin48h ~ age + fIndex4 + Antidol, data = data, method = "nearest")
matched48 <- match.data(match48)

match72 <- matchit(surgeryin72h ~ age + fIndex4 + Antidol, data = data, method = "nearest")
matched72 <- match.data(match72)

match96 <- matchit(surgeryin96h ~ age + fIndex4 + Antidol, data = data, method = "nearest")
matched96 <- match.data(match96)

# -------------------------
# 3. Modelli logistici sui dati matched
# -------------------------
fit48 <- glm(deceased ~ age + fIndex4 + Antidol + surgeryin48h, data = matched48, family = binomial)
fit72 <- glm(deceased ~ age + fIndex4 + Antidol + surgeryin72h, data = matched72, family = binomial)
fit96 <- glm(deceased ~ age + fIndex4 + Antidol + surgeryin96h, data = matched96, family = binomial)

# -------------------------
# 4. Funzione per estrarre OR + CI
# -------------------------
extract_or <- function(model, label) {
  broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
    select(term, estimate, conf.low, conf.high, p.value) %>%
    mutate(model = label)
}

# -------------------------
# 5. Combinare risultati
# -------------------------
results <- bind_rows(
  extract_or(fit48, "48h"),
  extract_or(fit72, "72h"),
  extract_or(fit96, "96h")
)

# Pulizia nomi variabili
results$term <- recode(results$term,
  "age" = "Age",
  "fIndex4TRUE" = "fIndex4",
  "AntidolTRUE" = "Antidol",
  "surgeryin48h1" = "Surgery ≤48h",
  "surgeryin72h1" = "Surgery ≤72h",
  "surgeryin96h1" = "Surgery ≤96h"
)

# Rimuovo intercetta
results <- filter(results, term != "(Intercept)")

 
# -------------------------
# 7. Tabella riassuntiva
# -------------------------
results_table <- results %>%
  mutate(OR_CI = sprintf("%.2f (%.2f – %.2f)", estimate, conf.low, conf.high),
         p.value = sprintf("%.3f", p.value)) %>%
  select(Model = model, Term = term, OR_CI, p.value)

kable(results_table, caption = "Logistic Regression Results: 48h, 72h, 96h")

```


```{r}
# Ordino i termini per leggibilità
results <- results %>%
  mutate(term = factor(term, levels = c("Age", "Antidol", "fIndex4", 
                                        "Surgery ≤48h", "Surgery ≤72h", "Surgery ≤96h")))

ggplot(results, aes(x = estimate, y = term,
                    xmin = conf.low, xmax = conf.high,
                    color = model)) +
  geom_pointrange(size = 0.8) +
  geom_vline(xintercept = 1, linetype = "dashed") +
  scale_x_log10() +   # scala logaritmica
  facet_wrap(~ model, scales = "free_x") +  # pannelli separati
  labs(title = "Forest Plot: Surgery Timing 48h, 72h, 96h",
       x = "Odds Ratio (95% CI, log scale)", y = "") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")  # leggenda non serve più, i facet parlano da soli
```

  Da questa tabella possiamo fare alcune osservazioni immediate:

🔹 1. Age

OR decresce leggermente passando da 48h → 72h → 96h: da 1.07 → 1.06 → 1.03

Nessun modello raggiunge significatività statistica (p > 0.05)

Tendenza: aumenta leggermente il rischio di mortalità con l’età, ma non è robusto nei dati matched.

🔹 2. fIndex4

48h: OR ≈ 3.16, p = 0.31 → non significativo

72h: OR ≈ 11.89, p = 0.016 → significativo, intervallo CI ampio (1.69 – 115.97)

96h: OR enorme e instabile (≈ 9.5e7), CI completamente instabile → separazione completa o categorie rare

Interpretazione:

Il rischio associato a fIndex4 aumenta con soglie più lunghe di tempo all’intervento, ma dopo 96h i dati sono troppo pochi o sbilanciati → stime non affidabili.

🔹 3. Antidol

Sempre OR < 1 → effetto protettivo

48h: OR ≈ 0.15, p = 0.03 → significativo

72h: OR ≈ 0.17, p = 0.066 → tendenza significativa

96h: OR ≈ 0.39, p = 0.375 → effetto attenuato e non significativo

Interpretazione:

L’effetto protettivo di Antidol è più chiaro quando l’intervento è entro 48h e tende a ridursi con tempi più lunghi.

🔹 4. Surgery ≤ X

Tutti i modelli: OR vicini a 1 o 0, non significativi

96h: OR = 0 con CI assurda → indicatore di separazione completa / numerosità molto bassa

Interpretazione:

Non emerge un effetto chiaro del timing della chirurgia sulla mortalità, soprattutto per soglie più lunghe.

Il modello a 96h è instabile e i risultati non sono interpretabili.

🔹 🔹 Messaggio globale

Antidol → protezione consistente entro le prime 48h.

fIndex4 → effetto significativo solo per 72h, ma molto instabile a 96h.

Surgery timing → nessun effetto robusto, soprattutto a 96h i dati non supportano stime affidabili.

Age → leggero trend, mai significativo nei matched data.

96h → separazione e rare categorie rendono OR e CI praticamente inutilizzabili.

Il modello più solido è quello 48h, che conferma l’effetto protettivo di Antidol e l’assenza di impatto significativo del timing chirurgico entro 48h.

## 4. Propensity Score Matching con matching 1:1 e caliper 0.2 per differenti soglie temporali (48h, 72h, 96h)

```{r}
run_psm <- function(data, treatment, outcome, covariates, caliper = 0.2, ratio = 1) {
  # 📌 Formula per propensity score
  formula_ps <- as.formula(
    paste(treatment, "~", paste(covariates, collapse = " + "))
  )
  
  # Matching
  match <- matchit(formula_ps,
                   data = data,
                   method = "nearest",
                   ratio = ratio,
                   caliper = caliper)
  
  matched_data <- match.data(match)
  
  # 🔍 Controllo: il trattamento ha almeno 2 livelli?
  if (length(unique(matched_data[[treatment]])) < 2) {
    warning(paste("⚠️ Dopo il matching", treatment, "ha un solo livello. Analisi saltata."))
    
    return(
      tibble(
        Model = treatment,
        term = treatment,
        estimate = NA,
        conf.low = NA,
        conf.high = NA,
        p.value = NA
      )
    )
  }
  
  # 📌 Modello logistico se i livelli sono validi
  formula_model <- as.formula(
    paste(outcome, "~", treatment, "+", paste(covariates, collapse = " + "))
  )
  
  model <- glm(formula_model, data = matched_data, family = binomial)
  
  # Risultati tidy
  results <- broom::tidy(model, conf.int = TRUE, exponentiate = TRUE) %>%
    filter(term == treatment) %>%
    mutate(Model = treatment) %>%
    select(Model, term, estimate, conf.low, conf.high, p.value)
  
  return(results)
}

kable(results, caption = "Logistic Regression Results (1:1 matching): 48h, 72h, 96h")
```

Commento:
🔹 48h

Age: OR ≈ 1.07, CI (1.00–1.17), p ≈ 0.078 → quasi significativo (effetto piccolo ma plausibile).

fIndex4: OR ≈ 3.16, CI molto larga, p = 0.306 → non significativo.

Antidol: OR ≈ 0.15, CI (0.18–0.67), p = 0.030 → significativo, effetto protettivo forte.

Surgery ≤48h: OR ≈ 1.13, CI (0.44–2.95), p = 0.79 → nessun effetto chiaro.

🔹 72h

Age: OR ≈ 1.06, CI (0.98–1.16), p = 0.194 → non significativo.

fIndex4: OR ≈ 11.9, CI (1.69–116), p = 0.016 → significativo, forte aumento del rischio.

Antidol: OR ≈ 0.17, CI (0.02–0.99), p = 0.066 → borderline, possibile protezione.

Surgery ≤72h: OR ≈ 0.42, CI (0.47–3.04), p = 0.401 → nessun effetto.

🔹 96h

Age: OR ≈ 1.03, CI (0.96–1.14), p = 0.454 → non significativo.

fIndex4: OR ≈ 9.5e7 (!!), CI larghissima e NA → segnale di instabilità/separazione nei dati (troppo pochi casi).

Antidol: OR ≈ 0.39, CI (0.04–2.83), p = 0.375 → non significativo.

Surgery ≤96h: OR ≈ 3.35e-8, CI NA–7.79e51, p = 0.994 → totalmente non interpretabile → problema di scarso bilanciamento o di pochi eventi.

📌 Conclusione pratica

Modello 48h: Antidol significativo (protettivo).

Modello 72h: fIndex4 significativo (rischio).

Modello 96h: risultati non interpretabili (instabilità statistica).

Limitiamo l'analisi a modelli 48h e 72h per robustezza.

--- Forest Plot comparativo ---

## 5. Assess balance (SMD pre/post, love plot). 

## 6. Outcome analysis (conditional logistic or Cox robust SE). Calculate RD, RR, HR.
## 7. Sensitivity analyses: IPTW, alternative timing cut-offs, alternative imputations.
## 8. Subgroups and interaction tests.

--- Fine ---